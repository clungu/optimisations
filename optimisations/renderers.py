# AUTOGENERATED! DO NOT EDIT! File to edit: 04_renderers.ipynb (unless otherwise specified).

__all__ = ['decorate_with_derivative_based_plot']

# Internal Cell
import matplotlib.animation as animation
from matplotlib import pyplot as plt
from IPython.display import HTML, display
from itertools import cycle
from typing import List, Union
from cycler import cycler
from functools import partial
from mpl_toolkits.mplot3d.art3d import Line3D, Poly3DCollection
import numpy as np
from itertools import islice

from .functions import Ifunction
from .graphics import plot_function
from .graphics import rotate
from .figures import Figure

# Internal Cell
from itertools import cycle
from typing import List
from functools import partial
from mpl_toolkits.mplot3d.art3d import Line3D, Poly3DCollection

class FixZorderLine3D(Line3D):
    @property
    def zorder(self):
        return 1000

    @zorder.setter
    def zorder(self, value):
        pass

def nth(iterable, n, default=None):
    """
    Returns the nth item or a default value
    """
    return next(islice(iterable, n, None), default)

# Internal Cell
COLORS = dict()

def get_color_of(name: str):
    global COLORS
    if name not in COLORS:
        color = nth(cycle('bgrcmyk'), len(COLORS))
        COLORS[name] = color
    else:
        color = COLORS.get(name)

    return color

# Cell
def decorate_with_derivative_based_plot(name_of_optimizer: str, history: np.ndarray, figure: Figure):
    """
    Decorates the given figure with the illustration of the progress made so far
    by the given optimiser. This function also increments one step into the optimisation process.

    Note: This decorating function should be used for derivative based optimisers as it only draws
    a single point for each time-step. Other optimisers could be displayed diffrently.
    """
    # we expect the `history` to be a list of (x, y) coordinates (so a single point per historical timestep)
    history = [(x, y, figure.function(x, y)) for x, y in history]

    x, y, z = list(zip(*history))
    x, y, z = np.array(x), np.array(y), np.array(z)

    #choose the color of this optimisere based on the `name_of_optimizer` string (should be the same every time, for the same optimiser)
    color = get_color_of(name_of_optimizer)

    # draw the line paths
    figure.ax_2d.plot(*rotate(x, y, angle=figure.angle), color=color, label=name_of_optimizer)
    lines = figure.ax_3d.plot3D(x, y, z, color=color, label=name_of_optimizer)

    # force the lines to be drawn on top (for the 3D plot)
    if figure.force_line_zorder:
        for line in lines:
            line.__class__ = FixZorderLine3D

    #draw the last points
    figure.ax_2d.scatter(*rotate(x[-1:], y[-1:], angle=figure.angle), color=color)
    figure.ax_3d.scatter3D(x[-1:], y[-1:], z[-1:], color=color)

    # add a legend to the chart
    figure.ax_2d.legend(loc=figure.legend_location)

    if figure.credits:
        # add a credits watermark such as not to overlap with the legend
        if figure.legend_location == "upper right":
            figure.ax_2d.text(1, 0, figure.credits, transform=figure.ax_2d.transAxes, ha='right',
                    color='#777777', bbox=dict(facecolor='white', alpha=0.8, edgecolor='white'))
        else:
            figure.ax_2d.text(1, 1, figure.credits, transform=figure.ax_2d.transAxes, ha='right',
                    color='#777777', bbox=dict(facecolor='white', alpha=0.8, edgecolor='white'))