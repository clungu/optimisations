# AUTOGENERATED! DO NOT EDIT! File to edit: 03_renderers.ipynb (unless otherwise specified).

__all__ = ['Figure', 'decorate_with_derivative_based_plot']

# Internal Cell
import matplotlib.animation as animation
from matplotlib import pyplot as plt
from IPython.display import HTML, display
from itertools import cycle
from typing import List, Union
from cycler import cycler
from functools import partial
from mpl_toolkits.mplot3d.art3d import Line3D, Poly3DCollection
import numpy as np
from itertools import islice

from .functions import Ifunction
from .graphics import plot_function
from .graphics import rotate

# Cell
class Figure:
    """
    This is a wrapper class that binds all the elements of a plot
    """
    def __init__(self, fig=None, ax_3d=None, ax_2d=None, angle=225, contour_log_scale=True, legend_location="upper right", azimuth_3d=30, zoom_factor=0, force_line_zorder=True, credits=None):
        self.fig = fig
        self.ax_3d = ax_3d
        self.ax_2d = ax_2d
        self.angle = angle
        self.contour_log_scale = contour_log_scale
        self.legend_location = legend_location
        self.azimuth_3d = azimuth_3d
        self.zoom_factor = zoom_factor
        self.force_line_zorder = force_line_zorder
        self.credits = credits

    def for_function(self, function: Ifunction):
        self.fig, self.ax_3d, self.ax_2d = plot_function(function, fig=self.fig, angle=self.angle, contour_log_scale=self.contour_log_scale, zoom_factor=self.zoom_factor)
        self.fig.tight_layout()
        return self

# Internal Cell
from itertools import cycle
from typing import List
from functools import partial
from mpl_toolkits.mplot3d.art3d import Line3D, Poly3DCollection

class FixZorderLine3D(Line3D):
    @property
    def zorder(self):
        return 1000

    @zorder.setter
    def zorder(self, value):
        pass

def nth(iterable, n, default=None):
    """
    Returns the nth item or a default value
    """
    return next(islice(iterable, n, None), default)

# Internal Cell
COLORS = dict()

def get_color_of(name: str):
    global COLORS
    if name not in COLORS:
        color = nth(cycle('bgrcmyk'), len(COLORS))
        COLORS[name] = color
    else:
        color = COLORS.get(name)

    return color

# Cell
def decorate_with_derivative_based_plot(name_of_optimizer: str, history: np.ndarray, figure: Figure):
    """
    Decorates the given figure with the illustration of the progress made so far
    by the given optimiser. This function also increments one step into the optimisation process.

    Note: This decorating function should be used for derivative based optimisers as it only draws
    a single point for each time-step. Other optimisers could be displayed diffrently.
    """
    # we expect the `history` to be a list of (x, y, z) coordinates (so a single point per histrical timestep)

    x, y, z = list(zip(*history))
    x, y, z = np.array(x), np.array(y), np.array(z)

    #choose the color of this optimisere based on the `name_of_optimizer` string (should be the same every time, for the same optimiser)
    color = get_color_of(name_of_optimizer)

    # draw the line paths
    figure.ax_2d.plot(*rotate(x, y, angle=figure.angle), color=color, label=name_of_optimizer)
    lines = figure.ax_3d.plot3D(x, y, z, color=color, label=name_of_optimizer)

    # force the lines to be drawn on top (for the 3D plot)
    if figure.force_line_zorder:
        for line in lines:
            line.__class__ = FixZorderLine3D

    #draw the last points
    figure.ax_2d.scatter(*rotate(x[-1:], y[-1:], angle=figure.angle), color=color)
    figure.ax_3d.scatter3D(x[-1:], y[-1:], z[-1:], color=color)

    # add a legend to the chart
    figure.ax_2d.legend(loc=figure.legend_location)

    if figure.credits:
        # add a credits watermark such as not to overlap with the legend
        if figure.legend_location == "upper right":
            figure.ax_2d.text(1, 0, figure.credits, transform=figure.ax_2d.transAxes, ha='right',
                    color='#777777', bbox=dict(facecolor='white', alpha=0.8, edgecolor='white'))
        else:
            figure.ax_2d.text(1, 1, figure.credits, transform=figure.ax_2d.transAxes, ha='right',
                    color='#777777', bbox=dict(facecolor='white', alpha=0.8, edgecolor='white'))