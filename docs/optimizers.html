---

title: Optimizers


keywords: fastai
sidebar: home_sidebar

summary: "This module implements interfaces and several known optimizers that can be tested against different functions"
description: "This module implements interfaces and several known optimizers that can be tested against different functions"
nb_path: "03_optimizers.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 03_optimizers.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="optimize" class="doc_header"><code>class</code> <code>optimize</code><a href="https://github.com/clungu/optimisations/tree/master/optimisations/optimizers.py#L47" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>optimize</code>(<strong><code>function</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">optimisations.functions</span> <span class="kn">import</span> <span class="n">himmelblau</span>
<span class="kn">from</span> <span class="nn">jax.experimental.optimizers</span> <span class="kn">import</span> <span class="n">sgd</span>

<span class="p">(</span>
    <span class="n">optimize</span><span class="p">(</span><span class="n">himmelblau</span><span class="p">())</span>
        <span class="o">.</span><span class="n">using</span><span class="p">(</span><span class="n">sgd</span><span class="p">(</span><span class="n">step_size</span><span class="o">=</span><span class="mf">0.001</span><span class="p">))</span>
        <span class="o">.</span><span class="n">start_from</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
        <span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[(1.0, 1.0), (1.046, 1.038), (1.093, 1.076), (1.141, 1.114), (1.189, 1.152), (1.238, 1.189), (1.288, 1.226), (1.338, 1.263), (1.389, 1.3), (1.44, 1.336), (1.491, 1.371)]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>JAX</code> is kind of rough, the optimizers (for now) sit inside the <code>experimental</code> submodule which means that their API might change in the future.</p>
<p>An optimizer is a function that has some initialization parameters, and which returns 3 functions:</p>
<ul>
<li><code>init</code> - is a function to which you pass all the initial values of your hidden parameters and you get back a <code>state</code> object, which is a <code>pytree</code> structure (some internal representation). This is a bit confusing and I'm guessing this intermediate <code>pytree</code> thing might disappear from the API in the near future.</li>
<li><code>update</code> - is the function that does a single update pass over the whole parameters. It receives as inputs:<ul>
<li><code>i</code> - the count of the current iteration. This usefull because, depending on the optimizer implementation, you can have different learning properties at each iteration (like some annealing strategy for the learning rate, etc..)</li>
<li><code>g</code> - the gradient values (you get these by extracting the params from the <code>state</code> function, using the <code>get_params</code> function bellow (these are the variables that will get updated by the optimizer). Then pass these onto your gradient function and its results as input to this function. </li>
<li><code>state</code> - that <code>pytre</code> structure that you've got after calling <code>init</code> (and which you'll contrantly replace with the result of this <code>update</code> function call)</li>
</ul>
</li>
<li><code>get_params</code> - a <code>utils</code> function that extracts the param object from a known <code>state</code> object (which is a <code>pytree</code>). </li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>So the full flow of the above, in code is shown bellow:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">jax.experimental.optimizers</span> <span class="kn">import</span> <span class="n">sgd</span>

<span class="n">init</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">get_params</span> <span class="o">=</span> <span class="n">sgd</span><span class="p">(</span><span class="n">step_size</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span> <span class="c1"># instantiate the optimizer</span>

<span class="n">state</span> <span class="o">=</span> <span class="n">init</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span> <span class="c1"># initialize the optimizer state with some initial weights and get a state back</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">get_params</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>    <span class="c1"># you use this function to extract the weight values from the state object</span>

<span class="n">grad_function</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">himmelblau</span><span class="p">(),</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># you build the function that will compute your gradients</span>
                                                    <span class="c1"># The argnum part is needed because we have to specify that there are two parameters the parent function uses, and we want the derivative to both of them.</span>
    
<span class="n">state</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">grad_function</span><span class="p">(</span><span class="o">*</span><span class="n">get_params</span><span class="p">(</span><span class="n">state</span><span class="p">)),</span> <span class="n">state</span><span class="p">)</span>    <span class="c1"># you call update with a iteration number, the gradient of the params, and the previous state and you get back a new state </span>
<span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>OptimizerState(packed_state=([1.0], [2.0]), tree_def=PyTreeDef(tuple, [*,*]), subtree_defs=(*, *))
(1.0, 2.0)
OptimizerState(packed_state=([DeviceArray(1.036, dtype=float32)], [DeviceArray(2.032, dtype=float32)]), tree_def=PyTreeDef(tuple, [*,*]), subtree_defs=(*, *))
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">grad</span>
<span class="kn">from</span> <span class="nn">optimisations.functions</span> <span class="kn">import</span> <span class="n">himmelblau</span>

<span class="n">grad</span><span class="p">(</span><span class="n">himmelblau</span><span class="p">(),</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))(</span><span class="o">*</span><span class="n">get_params</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(DeviceArray(-36.385605, dtype=float32),
 DeviceArray(-30.704094, dtype=float32))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And you can see the result of running 10 iterations of the above, in a loop. It moves to some direction, and I'm sure you're eager to see where, on the graph...</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">grad_function</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">himmelblau</span><span class="p">(),</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">init</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">get_params</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">params</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">grad_function</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">),</span> <span class="n">state</span><span class="p">)</span>
    
<span class="p">[(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">run</span><span class="p">()]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[(1.0, 2.0),
 (1.0360000133514404, 2.0320000648498535),
 (1.0723856687545776, 2.062704086303711),
 (1.1091352701187134, 2.092081069946289),
 (1.1462260484695435, 2.1201066970825195),
 (1.18363356590271, 2.1467630863189697),
 (1.22133207321167, 2.1720387935638428),
 (1.2592941522598267, 2.1959288120269775),
 (1.2974909543991089, 2.2184340953826904),
 (1.335891842842102, 2.239561080932617)]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="optimize_multi" class="doc_header"><code>class</code> <code>optimize_multi</code><a href="https://github.com/clungu/optimisations/tree/master/optimisations/optimizers.py#L96" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>optimize_multi</code>(<strong><code>function</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>When you want to compare the performance of multiple optimizers.</p>

</div>
</div>
</div>
</div>
 

